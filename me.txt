Cài docker và docker-compose trên EC2/AWS và Windows
    sudo yum update -y
    sudo yum install -y docker
    sudo service docker start
        service docker status -> Running
        docker -v
    (sudo usermod -a -G docker ec2-user)
    - Cài docker-compose
        sudo curl -L "https://github.com/docker/compose/rel...​ -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
Triển khai tạo Image, Container&Docker Hub
    https://www.youtube.com/watch?v=k5yvD4ykPcI
    Các lệnh với image
        - Tìm image để cài đặt
            docker search centos
        - List các image đang có
            docker image ls
        - Xóa image
            sudo docker rmi [Image ID]
            Chú ý: Các image mà có container đang chạy thì sẽ không xóa được mà phải xóa container liên quan tới nó trước
        - Pull image về
            docker pull centos:7
    Làm việc với container
        - Chạy 1 container từ image
            docker run --privileged -d -p 8080:80 [docker_image] /sbin/init
        - Vào container để chạy lệnh
            docker exec -it [Container ID] /bin/bash 
        - Cài đặt apache
            yum -y install httpd
            systemctl start httpd
            systemctl enable httpd
            EC2 Instances -> Security -> Security groups
            HTTP	    TCP	 80	    0.0.0.0/0
            Custom TCP	TCP	 8080   0.0.0.0/0
            SSH	        TCP	 22	    0.0.0.0/0
            HTTPS	    TCP	 443	0.0.0.0/0
            Access Browser http://18.188.155.79:8080/ to check
            echo "<html><body>Hello World</body></html>" > /var/www/html/index.html
            Access Browser http://18.188.155.79:8080/ to checks
        - Thoát ra khỏi container
            exit
        - Tạo image để triển khai cho máy khác
            docker commit -m "Comment" -a "Tác giả"  [Container ID] [Image Name]
            docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 
            docker commit -m "Centos Project1" -a "Vu Quang" 4d3621810593 vudinhquang/project1:v1
            (vudinhquang là tài khoản trên docker hub)
        - Đăng nhập vào docker hub
            docker login
        - Đưa image lên docker hup để mọi người cùng sử dụng
            docker push [Tên image]:[Tag]
            docker push vudinhquang/project1:v1
        - Check các container đang chạy
            sudo docker ps -a
        - Xem trạng thái container
            docker container ls -a
        - Xóa containner
            sudo docker rm [Container ID]
        - Stop container
            docker container stop [Container ID]
        - Restart container
            docker container restart [Container ID]
        - Create new EC2(Khách hàng)
            HTTP	    TCP	80	    0.0.0.0/0	
            Custom TCP	TCP	8080	0.0.0.0/0
            SSH	        TCP	22	    0.0.0.0/0
            sudo yum update -y
            sudo yum install -y docker
            sudo service docker start
                service docker status -> Running
                docker -v
            (sudo usermod -a -G docker ec2-user)
            - Cài docker-compose
                sudo curl -L "https://github.com/docker/compose/rel...​ -s)-$(uname -m)" -o /usr/local/bin/docker-compose
                sudo chmod +x /usr/local/bin/docker-compose
        - Đăng nhập vào docker hub(EC2 khách hàng )
            docker login
            sudo docker pull vudinhquang/project1:v1
            sudo su -
            docker images
            docker run --privileged -d -p 8080:80 vudinhquang/project1:v1 /sbin/init
            Access Browser http://18.191.99.67:8080/ to check
        EC2 ban đầu
            - Vào Container để sửa 
                docker ps: 4d3621810593
                docker exec -it 4d3621810593 /bin/bash 
                vi /var/www/html/index.html
                    <html><body>Hello World V2</body></html>
                Access Browser http://18.188.155.79:8080 to check
            - Tạo commit Version 2
                docker commit -m "Centos Project1 Version 2" -a "Vu Quang" 4d3621810593 vudinhquang/project1:v2
                docker push vudinhquang/project1:v2
        EC2 khách hàng  
            docker pull vudinhquang/project1:v2
            docker stop 76387f2f692b (stop container hiện tại)
            docker run --privileged -d -p 8080:80 vudinhquang/project1:v2 /sbin/init (chạy container version 2)
        - Pause container
            docker container pause  [Container ID]
        - Truy cập vào các container đang chạy
            docker container attach [Container ID]
        - Lệnh stop toàn bộ container
            docker stop $(docker ps -a -q)
        - Lệnh xóa toàn bộ container
            docker rm $(docker ps -a -q)
        - Lệnh xóa toàn bộ image
            docker rmi -f $(docker images -a -q)
Dockerfile
    Mục đích là build lên các Image bằng cách viết các câu lệnh trong Dockerfile
    Các lệnh trong Dockerfile
        FROM: Là base image để chúng ta tiến hành build một image mới. Command này phải được đặt trên cùng của Dockerfile
        MAINTAINER: Command này là tùy chọn, có thể có hoặc không. Nó chưa thông tin của người tiến hành xây dựng lên images.
        RUN: Sử dụng khi muốn thực thi một command trong quá trình build image
        COPY: Copy một file từ host machine tới docker image. Có thể sử dụng URL cho tệp tin cần copy, khi đó docker sẽ tiến 
            hành tải tệp tin đó đến thư mục đích.
        ARG: Định nghĩa các biến cho quá trình build docker image. Biến này chỉ có scope khi build image, không sử dụng được 
            khi docker container running.
            Cách truyền khi chạy lệnh docker build:
                --build-arg key1=value1
                --build-arg key2=value2
        ENV: Định nghĩa các biến môi trường. ENV có thể được gán bằng 2 cách:
            Gán giá trị mặc định thông qua biến ARG khi build image
            Gán trực tiếp hoặc override khi run container
        WORKDIR: Định nghĩa directory cho CMD
        USER: Đặt user hoặc UID cho container được tạo bởi image
        VOLUME: Cho phép truy cập / liên kết thư mục giữa các container và máy chủ (host machine)
        ENTRYPOINT: Định nghĩa những commands sẽ được chạy đầu tiên khi container chạy.
            Các lệnh thêm vào sau docker run [OPTIONS] [Extra COMMANDs] sẽ được thêm vào chuỗi các commands của entrypoint
        CMD: Định nghĩa các commands mặc định khi không có ENTRYPOINT và Extra COMMANDS
        EXPOSE: Lệnh EXPOSE thông báo cho Docker cho container lắng nghe trên các cổng mạng được chỉ định khi chạy
    Chuẩn bị: 
        Folder code:
            index.html
            test.php
    1. Tạo Dockerfile
        # Get base image
        FROM centos:7

        # Author
        MAINTAINER "Vu Quang"

        #Cai​ dat apache
        RUN yum update -y
        RUN yum install -y sudo
        RUN yum install -y epel-release
        RUN yum install -y https://rpms.remirepo.net/enterprise/remi-release-7.rpm
        RUN yum clean all
        RUN yum -y install wget
        RUN yum -y install httpd
        RUN yum -y install --enablerepo=remi,remi-php71 php php-devel php-mbstring php-pdo php-gd php-xml php-mcrypt php-pgsql
        
        #Thiet​ lap thu muc lam viec 
        WORKDIR /var/www/html

        #copy​ code tu thu muc code vao image
        ADD ./code /var/www/html

        # start httpd
        CMD ["/usr/sbin/httpd", "-D", "FOREGROUND"]

        EXPOSE 80
    2. Build image
        docker build -t httpd_sample .
    3. Tạo và chạy container
        docker run -d -p 80:80 httpd_sample
    Access Browser to check: 
        http://3.138.186.116
        http://3.138.186.116/test.php
    - Lệnh stop toàn bộ container
        docker stop $(docker ps -a -q)
    - Lệnh xóa toàn bộ container
        docker rm $(docker ps -a -q)
    - Lệnh xóa toàn bộ image
        docker rmi -f $(docker images -a -q)
Docker-compose
    Các lệnh Docker-compose:
        version: chỉ ra phiên bản docker-compose đã sử dụng.
        services: thiết lập các services(containers) muốn cài đặt và chạy.
        image: chỉ ra image được sử dụng trong lúc tạo ra container.
        build: dùng để tạo container.
        ports: thiết lập ports chạy tại máy host và trong container.
        restart: tự động khởi chạy khi container bị tắt.
        environment: thiết lập biến môi trường ( thường sử dụng trong lúc config các thông số của db).
        depends_on: chỉ ra sự phụ thuộc. Tức là services nào phải được cài đặt và chạy trước thì service được config tại đó mới được chạy.
        volumes: dùng để mount hai thư mục trên host và container với nhau.
    1. Cài EC2
        #!/bin/bash
        yum update -y
        yum install -y docker
        service docker start
        chkconfig docker on
        curl -L "https://github.com/docker/compose/releases/download/1.11.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        chmod +x /usr/local/bin/docker-compose
    2. Sample
        Chuẩn bị: 
            Folder code:
                index.html
                phpinfo.php
        1. Tạo file Dockerfile
            FROM centos:7
            RUN yum -y update && \
                yum -y install httpd php
            WORKDIR /var/www/html
            ADD ./code /var/www/html
            EXPOSE 80
        2.Tạo file docker-compose.yml
            version: '3'
            services:                                                                                       
            web:                                                                                          
                build: .
                command: ["/usr/sbin/httpd","-D","FOREGROUND"]           
                ports:                                                                                      
                - "80:80"
        - Build image
            docker-compose build
        - Chạy container
            docker-compose up -d
        Access Browser to check: 
            http://3.138.186.116
            http://3.138.186.116/phpinfo.php
        - Stop
            docker-compose stop
        - Start lại container
            docker-compose start
        - Stop và xóa container
            docker-compose down
        - Lệnh stop toàn bộ container
            docker stop $(docker ps -a -q)
        - Lệnh xóa toàn bộ container
            docker rm $(docker ps -a -q)
        - Lệnh xóa toàn bộ image
            docker rmi -f $(docker images -a -q)
Docker Volume, Networks
    1. Docker volume
        Là một nơi lưu trữ data nằm ngoài container, mục đích không làm mất data khi xóa container
        Sử dụng Volume khi nào 
            - Khi chia sẻ dữ liệu giữa nhiều container đang chạy.
            - Lưu dữ liệu tới một server remote hoặc cloud.
            - Khi cần backup, restore hoặc migrate dữ liệu từ Docker Host này sang Docker Host khác.
        Lệnh liên quan tới volume
            docker volume create        Tạo volume mới
            docker volume inspect       Xem chi tiết volume
            docker volume ls             Hiển thị những volume đang có
            docker volume rm             Xóa volume
            docker volume prune         Xóa toàn bộ volume
    Docker volume Example
        1. Cài EC2
            #!/bin/bash
            yum update -y
            yum install -y docker
            service docker start
            chkconfig docker on
            curl -L "https://github.com/docker/compose/releases/download/1.11.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose
        Ví dụ Volume 1
            docker volume create project01_code
            docker volume inspect project01_code
            docker run --name project01 -p 8080:80 -v project01_code:/usr/local/apache2/htdocs -d httpd
        Ví dụ Volume 2
            EC2 Instances -> Security -> Security groups
                MYSQL/Aurora	TCP	3306	0.0.0.0/0
            (docker container run --name mysql -e MYSQL_ROOT_PASSWORD=pass -p 3306:3306 -d mysql:5.7)
            docker volume create pj01_data
            docker container run --name mysql -v pj01_data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=pass -p 3306:3306 -d mysql:5.7
            connect by mysql
                Hostname: 18.222.158.139
                Port: 3306
                Username: root 
                Password: pass 
            Create database: test_docker 
            Create table: hocsinh(id, name)
            Insert data:
                1, A
                2, B
                3, C
                4, D
            - Stop toàn bộ container
                docker stop $(docker ps -a -q)
            - Xóa toàn bộ container
                docker rm $(docker ps -a -q)
            - Xóa toàn bộ image
                docker rmi -f $(docker images -a -q)
            Build lại Container: 
                docker container run --name mysql -v pj01_data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=pass -p 3306:3306 -d mysql:5.7
            Connect by mysql and test
                SELECT * FROM test_doker.hocsinh;
    2. Docker networks
        Để kết nối các container trong cùng mạng hoặc khác mạng với nhau.
        Các câu lệnh thao tác với Docker networks
            docker network create        Tạo mạng mới
            docker network inspect       Xem chi tiết mạng
            docker network ls             Hiển thị những mạng đang có
            docker network rm            Xóa mạng
            docker network prune         Xóa đồng loạt các mạng không sử dụng
            docker network connect       Tạo kết nối mạng
            docker network disconnect    Ngắt kết nối mạng
        Ví dụ 1
            Tạo 1 mạng lớp C
                docker network create --subnet 192.168.1.0/24 network1
            Tạo ra 2 container kết nối với mạng này
                docker run -itd --name=container1  --network network1 busybox
                docker run -itd --name=container2  --network network1 busybox
            docker network inspect network1
                container1: 192.168.1.2/24
                container2: 192.168.1.3/24
            Kiểm tra kết nối giữa 2 mạng
                docker attach container1
                ping 192.168.1.3
        Ví dụ 2
            docker run --name mysql --network network1 -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.7
            docker run --name wordpress --network network1 -e WORDPRESS_DB_PASSWORD=my-secret-pw -p 8080:80 -d wordpress
            Access Browser http://3.141.103.242:8080/ to check Wordpress(username: admin, password: 123456)
    Sample 1 tạo DB MYSQL
        - Stop toàn bộ container
            docker stop $(docker ps -a -q)
        - Xóa toàn bộ container
            docker rm $(docker ps -a -q)
        - Xóa toàn bộ image
            docker rmi -f $(docker images -a -q)
        sample-project/
                    ├ docker/
                    |       └ mysql/
                    |              ├ conf.d/
                    |              |       └ my.cnf
                    |              ├ initdb.d/
                    |              |         ├ schema.sql
                    |              |         └ testdata.sql
                    |              └ Dockerfile
                    ├ log/mysql
                    |
                    └ docker-compose.yml    
        mkdir pj03
        cd pj03
        mkdir -p docker/mysql/conf.d
        mkdir -p docker/mysql/initdb.d
        mkdir -p log/mysql
        chmod -Rf 777 log
        vi docker/mysql/conf.d/my.cnf
            [mysqld]
            character-set-server=utf8mb4
            explicit-defaults-for-timestamp=1
            general-log=1
            general-log-file=/var/log/mysql/mysqld.log

            [client]
            default-character-set=utf8mb4
        vi docker/mysql/initdb.d/schema.sql
            CREATE TABLE users (
                id INT NOT NULL AUTO_INCREMENT,
                name VARCHAR(32) NOT NULL,
                email VARCHAR(32) NOT NULL,
                PRIMARY KEY (id)
            );
        vi docker/mysql/initdb.d/testdata.sql
            INSERT INTO users (id,name,email) VALUES (1, 'Tuc Anh Ach','achsan@gamil.com');
        vi docker/mysql/Dockerfile
            FROM mysql:5.7
            RUN touch /var/log/mysql/mysqld.log
        vi docker-compose.yml
            version: '3'
            services:
                db:
                    build: ./docker/mysql
                    image: mysql:5.7
                    restart: always
                    environment:
                        MYSQL_DATABASE: sample_db
                        MYSQL_USER: user
                        MYSQL_PASSWORD: password
                        MYSQL_ROOT_PASSWORD: rootpassword
                    ports:
                        - "3314:3306"
                    volumes:
                        - ./docker/mysql/initdb.d:/docker-entrypoint-initdb.d
                        - ./docker/mysql/conf.d:/etc/mysql/conf.d
                        - ./log/mysql:/var/log/mysql
                        - mysql_data:/var/lib/mysql
            volumes:
                mysql_data:
        - Build container
            docker-compose up -d 
        - EC2 -> Security Groups
            Custom TCP	TCP	3314	0.0.0.0/0
        - Check by mysql Workbench
            user: user, password: password, port: 3314
            INSERT INTO `sample_db`.`users` (`id`, `name`, `email`) VALUES ('2', 'Vu Quang', 'quang@gmail.com');
        - Stop toàn bộ container
            docker stop $(docker ps -a -q)
        - Xóa toàn bộ container
            docker rm $(docker ps -a -q)
        - Xóa toàn bộ image
            docker rmi -f $(docker images -a -q)
        - Build container
            docker-compose up -d 
        - Check by mysql Workbench again
    Sample 2
        - Stop toàn bộ container
            docker stop $(docker ps -a -q)
        - Xóa toàn bộ container
            docker rm $(docker ps -a -q)
        - Xóa toàn bộ image
            docker rmi -f $(docker images -a -q)
        mkdir pj05
        cd pj05 
        docker-compose.yml
            version: "3"
            services:
            wordpress:
                image: wordpress:latest
                container_name: pj10_wordpress
                volumes:
                - "$PWD:/var/www/html"
                - "$PWD/docker/backup:/tmp/backup"
                - "$PWD/docker/log:/tmp/log"
                ports:
                - 8080:80
                depends_on:
                - db
                environment:
                WORDPRESS_DB_HOST: "db:3306"
                networks:
                - pj10_network
                env_file: .env

            db:
                image: mysql:5.7
                container_name: pj10_mysql
                volumes:
                - "db-data:/var/lib/mysql"
                networks:
                - pj10_network
                env_file: .env

            volumes:
            db-data:

            networks:
            pj10_network:
        File .env
            WORDPRESS_DB_NAME=wordpress
            WORDPRESS_DB_USER=admin
            WORDPRESS_DB_PASSWORD=pass

            MYSQL_RANDOM_ROOT_PASSWORD=yes
            MYSQL_DATABASE=wordpress
            MYSQL_USER=admin
            MYSQL_PASSWORD=pass
        - Build container
            docker-compose up -d 
        - Check by mysql Workbench
            user: admin, password: pass, port: 3306
        - Access Browser: http://3.141.103.242:8080/
Triển khai docker image lên AWS ECS(Amazon Elastic Container Service )
    Mục đích để đưa các Docker image lên để chạy 
    1. Tạo IAM user
        Groups(name: docker)
            AmazonEC2ContainerRegistryFullAccess
            AmazonECS_FullAccess
        Users
            User name: docker-iam 
            Access type: Programmatic access
        Download: new_user_credentials.csv to use Access key ID and Secret access key
    2. Cài EC2
        #!/bin/bash
        yum update -y
        yum install -y docker
        service docker start
        chkconfig docker on
        curl -L "https://github.com/docker/compose/releases/download/1.11.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        chmod +x /usr/local/bin/docker-compose
    3. Cấu hình AWS CLI
        command: aws configure
            AWS Access Key ID [None]: *******
            AWS Secret Access Key [None]: ********
            Default region name [None]: us-east-2
            Default output format [None]: json
        check by command: aws configure list
    4. Tạo docker image
        AMAZON ECR
        mkdir nginx
        cd nginx
        vi Dockerfile
            FROM nginx
            COPY html /usr/share/nginx/html
        mkdir html
        vi html/index.html
            <html>
            <head><title>Hello</title></head>
            <body><h1>AWS ECS</h1></body>
            </html>
        docker build -t [Image Name]:tag .
	        -> docker build -t docker_aws_ecs:v1 .
        - Tạo repository lên AWS/ECR(Amazon Elastic Container Registry)
            aws ecr create-repository --repository-name [Repository Name] --region us-east-2
            -> aws ecr create-repository --repository-name docker_aws_ecs --region us-east-2
            -> ECR -> Repositories to check repository created
        - Tạo tag version docker image
            docker tag [Image Name]:tag [Repository ULR] đã tạo ra ở bước trên]
            -> docker tag docker_aws_ecs:v1 954822992399.dkr.ecr.us-east-2.amazonaws.com/docker_aws_ecs
        - AWS ECR Login
            aws ecr get-login --no-include-email --region us-east-2
        - Push lên AWS/ECR
            docker push [Repository ULR]
            -> docker push 954822992399.dkr.ecr.us-east-2.amazonaws.com/docker_aws_ecs
        - Tạo Task trên AWC/ECS
            Task Definitions
            Task Definition Name: docker
            Network Mode: Bridge
            Add container:
                Container name: docker-container
                Image: 954822992399.dkr.ecr.us-east-2.amazonaws.com/docker_aws_ecs
                Memory Limits (MiB): 512
                Port mappings: 80 - 80
        - Tạo Clusters trên AWC/ECS
            EC2 Linux + Networking
            Cluster name: docker-cluster
            EC2 instance type: t2.micro 
            Number of instances: 3
            Key pair: deploy
        - Cluster - Services - Create
            Launch type: EC2
            Service name: docker-service
            Service type: DAEMON
            Clusters  -> ECS Instances -> Public IPv4 address
        - Chạy và kiểm tra thành quả
            Access Browser to test: http://3.139.70.243/
            AWS ECS is displayed
    Các lệnh xóa đồng loạt
        docker stop $(docker ps -a -q)
        docker rm $(docker ps -a -q)
        docker rmi -f $(docker images -a -q)

==============================================================================================================
==============================================================================================================

                    Understanding Docker Run with Volume mounting and important flags step by step
Cài EC2
    #!/bin/bash
    yum update -y
    yum install -y docker
    service docker start
    chkconfig docker on
    curl -L "https://github.com/docker/compose/releases/download/1.11.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    chmod +x /usr/local/bin/docker-compose
Các lệnh xóa đồng loạt
    docker stop $(docker ps -a -q)
    docker rm $(docker ps -a -q)
    docker rmi -f $(docker images -a -q)
Running a single Docker Container Explained Step By Step
    docker run -it ubuntu /bin/bash
        it: interactive and terminal(Chạy và đồng thời vào Container)
        - Ctrl+p+q: Container vẫn còn được chạy đồng thời quay về Terminal của EC2
        - Exit: Container ngừng
    docker ps
        lists the currently running container
    docker ps -a
        Lists all containers, the running ones and the empty ones
    docker start container_identifier
        We can restart a container that was previously running
    docker attach container_identifier
        We can re-attach to the container
        Re attach lại container đã được chạy và dùng Ctrl+p+q để quay về Terminal của EC2
    docker stop container_identifier
        stop the running container
    docker rm container_identifier
        Clean up: Remove the container
Running multiple Docker Containers, detaching and docker attach step by step
    docker run -it -d --rm --name linux1 ubuntu /bin/bash
        -d starts the container as “detached”. Use “docker attach” to attach to it later on.
        --rm cleans up the container after stopping. The container will be removed, basically
            the same as “docker rm container_identifier” after stopping the container. So
            everything is kept tidy
            Cũng bị xóa sau lệnh exit sau khi đã attach vào Container
        --name will give the container a dedicated name, which makes it easier to address
            the container later on.
    docker run -it -d --rm --name linux2 ubuntu /bin/bash
        Tài nguyên của linux1 và linux2 là khác nhau và không được chia sẻ mặc dù chúng đề được tạo ra từ image ubuntu
Running Docker Containers with a Shared Host File System (Volume Mounting)
    docker run --rm -v ${PWD}:/myvol ubuntu /bin/bash -c "ls -lha > /myvol/myfile.txt"
        This command runs “ls -lha” and pipes the output to /myvol/myfile.txt
        /myvol is “mounted” to the current working directory on the host
        On the host you can observe a new file called “myfile.txt” with the output of “ls -lha
        The container is then ended and removed because of “--rm"
    docker run -it -v ${PWD}:/myvol ubuntu /bin/bash
    In Container:
        touch file2 
        echo "test" > file2
        exit 
    Check file2 in host EC2 
Running PHP Scripts with Volume Mounting in Docker Containers - Practical Example
    docker run -it --rm -v ${PWD}:/myfiles --name my-running-script php:7.0-cli /bin/bash
        Running the php 7.0, not the php 7.2 cli
        And we are mounting the root directory into the /myfiles directory inside the container
    In Container
        echo '<? echo "test text\n";' > /myfiles/index.php
    exit 
    docker run -it --rm -v ${PWD}:/myfiles --name my-running-script php:7.2-cli /bin/bash
    In Container 
        php /myfiles/index.php
    docker run -it --rm -v ${PWD}:/myfiles -w /myfiles --name myrunning-script php:7.2-cli php index.php
        Will directory run index.php and output the “test text” and exit again
        No need to actually enter the container(/bin/bash will enter the container)
        -w flag again sets the working directory to /myfiles
How to access Server Logs in Docker and How to do Port Forwarding in Docker
    docker run -d httpd
        Will start an apache in detached mode (-d)
        It should open a webserver on port 80
    docker exec -it container_identifier /bin/bash
        -> docker exec -it 369235e9603a /bin/bash
    apt-get update 
    apt-get install curl
    curl localhost:80
    exit 
    docker logs container_identifier
        -> docker logs 369235e9603a
        Do not have see the request from inside the container
    docker logs container_identifier -f
        -> docker logs 369235e9603a -f
            Will follow the log output until you hit ctrl+c
            http://18.224.137.19/ doesn’t do anything
    docker inspect container_identifier
        -> docker inspect 369235e9603a
        Will print out the container information
        You see there are no ports bound to the host
            "PortBindings": {},
    docker rm -f 369235e9603a
        docker run -d -p 8080:80 httpd
            -p 8080:80 forwards HOST:GUEST
            On the host machine port 8080 is now mapped to port 80 in the guest machine
    Open http://18.224.137.19:8080    
        Should bring up now “it works”
    docker inspect 4ff6f3c83290
        Now shows the forwarded port
            "PortBindings": {
                "80/tcp": [
                    {
                        "HostIp": "",
                        "HostPort": "8080"
                    }
                ]
            }
    docker rm -f 4ff6f3c83290
    docker run -d -p 8080:80 -v ${PWD}:/var/www/html php:7.2-apache
    docker exec -it 5928b213a9a8 /bin/bash
    chmod 755 /var/www/html/
    Open http://18.224.137.19:8080/

            ----------------------------------------------------------------------------------------
                    Creating Docker Images and a Custom Configuration with Dockerfile in Docker

Write your first Dockerfile Step-By-Step Explained for Beginners
    Create this Dockerfile:
        FROM php:7.2-cli
        RUN mkdir /myproject
        COPY index.php /myproject
        WORKDIR /myproject
        CMD php index.php
    index.php
        echo "Hello World\n\n";
    docker build -t myphpapp .
        “build” builds a new image
        -t is a tagging. In this case “myphpapp”, you can later find it.
        “.” is telling where the Dockerfile is located at 
    docker run myphpapp
    docker image ls
    docker ps -a
    docker rm container_identifier
        Remove the container from the myphpapp
    docker rmi myphpapp
        rmi will delete an image
Use a custom PHP Development Server inside a Container based on a Dockerfile
    Dockerfile:
        FROM php:7.2-cli
        EXPOSE 8000
        RUN mkdir /myproject
        COPY index.php /myproject
        WORKDIR /myproject
        CMD ["php", "-S", "0.0.0.0:8000"]
    docker build -t myphpapp .
        Will run “php -S 0.0.0.0:8000” and serve the content of /myproject on port 8000
        CMD will take an array and run a command. Every parameter must be in a separate array
            element, so: CMD [“command”,”param1”, “param2”, …]
    docker run --name myphp-container -p 8080:8000 myphpapp
        Will forward port 8000 in the container to port 8080 on the host
    Open http://18.224.137.19:8080/ to check
    ctrl+c
        Stop the container
        The container is still running in the background.
Ship your Web-Application using Apache/PHP as Docker Image with a Dockerfile
    Dockerfile:
        FROM php:7.2-apache
        COPY index.php /var/www/html
    index.php:
    docker build -t myphpapp .
        This will build an image myphpapp:latest
        Will copy the index.php from the host inside the container in the directory /var/www/html
    docker run --name myphp-apache -p 8080:80 myphpapp
        Will run the image myphpapp image
        Bind port 8080 on the host to port 80 on the guest
        Will give the container the name “myphp-apache”
    Open http://18.224.137.19:8080/ to check
Upload Custom Images to Docker-Hub Image Repository
    Dockerfile:
        FROM alpine
        RUN apk update && apk add curl
        ENTRYPOINT [ "curl" ]
    Run
    docker build -t mycurl .
    docker run --rm mycurl www.google.com
        Should output the HTML from the google website
    docker login
    docker tag mycurl vudinhquang/mycurl:latest
        Tag your image with “username/repository:tag” -> vudinhquang/mycurl:latest
    docker image ls
        Lists also the new image as well, with the same images ID
    docker push vudinhquang/mycurl:latest
        Pushes the image to docker hub
    docker rmi mycurl
    docker rmi vudinhquang/mycurl:latest
    docker run --rm vudinhquang/mycurl:latest www.google.com
        It will download the image again from docker hub from your public repository

            ----------------------------------------------------------------------------------------
                    Reading, Understanding and Writing docker-compose.yml files step by step

The docker-compose.yml File Explained Line-by-Line
    Dockerfile
        FROM php:7.2-apache
        COPY index.php /var/www/html
    index.php
        echo "hello world \n\n";
    docker-compose.yml
        version: '3'
        services:
        phpapp:
            ports:
            - "8080:80"
            build:
            context: ./
            dockerfile: Dockerfile
    Run 
        docker-compose up
            It will read the docker-compose.yml file in the current directory
            It will build a new image “folder-name”_”service-name” based on the Dockerfile
                called "dockercompose_phpapp"
            It will run this as a container named “folder-name”_”service_name”_”index”
                So: "dockercompose_phpapp_1"
        Open http://3.16.206.112:8080/ to check
        ctrl-c
            Stop the running container(s)
        Edit index.php: "hello world" to "hello docker"
            echo "hello docker \n\n";
        docker-compose up
            Start the container(s) again
        Open http://3.16.206.112:8080/ should still bring up “hello world”.
        docker-compose up --build
            This rebuilds the image before spinning it up
            Now http://3.16.206.112:8080/ container "hello docker"
        docker-compose rm
            Cleanup, remove the containers
This is how you use Docker-Compose to Start and Stop Services
    docker-compose.yml
        version: '3'
        services:
            phpapp:
                image: php:7.2-apache
                ports:
                    - "8080:80"
                volumes:
                    - "./:/var/www/html"
    index.php
        echo "hello world \n\n";
    Run 
        docker-compose up
        It will mount the current directory to /var/www/html dynamically
        Open http://3.16.206.112:8080/ to check
    Let’s change “hello world” in the index.php to “hello docker” and save it.
    Then reload your browser
    Open http://3.16.206.112:8080/ to check -> “hello docker” displayed
    ctrl-c
    docker-compose rm
        Remove the unnecessary containers
Build your own Images with Custom Configuration using Docker-Compose
    docker-compose.yml
        version: '3'
        services:
            phpapp:
                build:
                    context: ./
                    dockerfile: Dockerfile
                image: phpapp:123
                ports:
                    - "8080:80"
                volumes:
                    - "./:/var/www/html"
                container_name: my-php-app
    Dockerfile
        FROM php:7.2-apache
        RUN apt-get -y update \
        && apt-get install -y libicu-dev \
        && docker-php-ext-configure intl \
        && docker-php-ext-install intl
        RUN docker-php-ext-install mysqli && docker-php-ext-enable mysqli
    index.php 
        <?php
        phpinfo();
    docker-compose up
        The image name is “phpapp:123” and not the directory_name… anymore.
        It will run this as a container named "my-php-app" not the “folder-name”_”service_name”_”index” anymore
    Open http://3.135.61.64:8080/ to check -> “hello docker” displayed
A Sample Development Environment (PHP/Apache/MySQL) using docker-compose.yml
    docker-compose.yml
        version: '3'
        services:
        phpapp:
            build:
                context: ./
                dockerfile: Dockerfile
            image: phpapp:123
            ports:
                - "8080:80"
            volumes:
                - "./:/var/www/html"
            container_name: myphpapp-app

        db:
            image: mysql:5.7
            #restart: always
            ports:
                - "3306:3306"
            environment:
                MYSQL_ROOT_PASSWORD: root
                MYSQL_DATABASE: wp2017
                MYSQL_USER: wp
                MYSQL_PASSWORD: wp2017
                container_name: myphpapp-db
    Dockerfile
        FROM php:7.2-apache
        RUN docker-php-ext-install mysqli && docker-php-ext-enable mysqli
    index.php 
        <?php
        header("content-type: text");
        $serverName = 'db'; //The hostname "db" from our docker-compose.yml file!!!
        $userName = 'wp';
        $password = 'wp2017';
        $dbName = 'wp2017';
        $conn = new mysqli($serverName, $userName, $password, $dbName);
        if ($conn->connect_errno > 0) {
            echo $db->connect_error;
        } else {
            echo "DB Connection successful\n\n";
            //we read out the content
            $result=mysqli_query($conn,"SHOW DATABASES;");
            while( $row = mysqli_fetch_row( $result ) ){
                echo $row[0]."\n";
            } 
        }
    docker-compose up -d
        Downloads the image "mysql:5.7" and starts it

    Open http://3.135.61.64:8080/ and see if you can see a “DB Connection successful”
    docker logs myphpapp-app -f
        This attaches to the stdout logs of the myphpapp-app container
        Every time you reload the website you should see a new request
    docker-compose ps
        Lists the Services running
    docker-compose down
        Shuts down the two services
        And removes them
    